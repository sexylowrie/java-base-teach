#### 设计模式之备受欢迎的代理模式

代理模式是在我们的日常生活以及开发学习中应用十分广泛的一种设计模式；房屋租赁的过程中，我们如果没有办法可以直接找到房东，可以通过中介或者代理去完成承租；而在程序的世界里这样的例子也是数不胜数。

#### 代理模式

与房屋租赁的场景类似，当客户端无法直接引用或者使用目标对象时，可以通过代理对象搭建起客户端对象与目标对象的桥梁；这样的设计思路，通过代理对象保护了目标对象，由代理对象担任客户端与目标对象的中介，便于扩展；而目标对象的职责也更加清晰明了。在代理模式中一般分为两种，一种是静态代理，一种是动态代理。

#### 静态代理

静态代理是指在**程序编译阶段**就已经明确了代理对象与目标对象的关系。

java代码实现如下：

接口类：
```
public interface PayInterface {

    /**
     * 支付接口
     */
    String pay();

}
```

目标类：
```
//目标类实现接口
public class PayImpl implements PayInterface {

    @Override
    public String pay() {
        System.out.println("支付成功");
        return "pay success";
    }
}
```

代理类：
```
//实现接口，职责由具体实现类完成
public class PayProxy implements PayInterface {

    /**目标对象*/
    private PayInterface payInterface;
    
    /**代理对象*/
    public PayProxy(PayInterface payInterface) {
        this.payInterface = payInterface;
    }
        
    @Override
    public String pay() {
        System.out.println("进入代理类");
        return payInterface.pay();
    }
}
```

演示Demo：
```
/**
 * 代理模式示例
 * 静态代理
 */
public class ProxyDemo {


    public static void main(String[] args) {
        PayProxy payProxy = new PayProxy(new PayImpl());
        payProxy.pay();
    }

}
```


#### 动态代理

动态代理则是在**程序运行阶段**才明确代理对象与目标对象的关系；我们常见的动态代理的实现方式有两种；一种是jdk的动态代理，一种是cglib的动态代理；以下我们分别来演示一下两种实现。

##### jdk动态代理

接口类与实现类：同上
```
public interface PayInterface {

    /**
     * 支付接口
     */
    String pay();

}

public class PayImpl implements PayInterface {

    @Override
    public String pay() {
        System.out.println("支付成功");
        return "pay success";
    }
}
```

代理类如下：
```
//需要实现InvocationHandler 接口
public class DynamicPayProxy implements InvocationHandler {

    /**目标对象*/
    private Object target;


    /**获取代理对象实例*/
    public Object newProxyInstance(Object target) {
        this.target = target;
        Class<?> clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);
    }

    /**方法调用*/
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("进入代理类");
        Object invoke = null;
        try {
            invoke = method.invoke(target, args);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return invoke;
    }
}
```

演示Demo：
```
public class DynamicProxyDemo {

    public static void main(String[] args) {
        DynamicPayProxy proxy = new DynamicPayProxy();
        PayInterface payInstance = (PayInterface) proxy.newProxyInstance(new PayImpl());
        payInstance.pay();
    }
}
```

通过比较动态代理与静态代理的代理类的实现，我们发现代理的目标对象从PayInterface 升级为 Object ;方法也不在局限于 pay()方法。动态代理还有另一种实现是通过cglib，需要引入相关的jar包

目标类与jdk目标类一直，不在需要接口类PayInterface：
```
public class PayImpl implements PayInterface {

    @Override
    public String pay() {
        System.out.println("支付成功");
        return "pay success";
    }
}
```

代理类：
```
/**需要引入cglib相关jar包*/
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

//需要实现MethodInterceptor
public class CglibPayProxy implements MethodInterceptor {


    /**
     * 构建代理对象
     * 代理对象是目标类的子类
     */
    public Object newProxyInstance(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("进入cglib代理类");
        return methodProxy.invokeSuper(o, objects);
    }
}

```

演示demo：
```
public class CglibProxyDemo {

    public static void main(String[] args) {
        CglibPayProxy proxy = new CglibPayProxy();
        PayInterface payInstance = (PayInterface) proxy.newProxyInstance(new PayImpl());
        payInstance.pay();
    }
}
```


通过调试以上代码，我们发现

* jdk的动态代理，依赖接口类，可以说是在接口的基础上实现的代理；需要实现InvocationHandler
    
* 而cglib的动态代理是通过构建目标类的子类，然后通过子类调用父类方法来实现的，所以声明为final的类将无法被代理；需要实现MethodInterceptor。





